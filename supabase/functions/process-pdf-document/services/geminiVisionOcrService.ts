// Gemini Vision OCR Service for direct PDF processing
// Optimized for large scanned legal documents

export interface GeminiOcrResult {
  text: string;
  confidence: number;
  pageCount: number;
  processingTime: number;
  processingNotes: string;
}

export async function extractTextWithGeminiVision(
  pdfData: Uint8Array,
  fileName: string
): Promise<GeminiOcrResult> {
  console.log('ü§ñ Starting Gemini Vision direct PDF processing...');
  console.log(`File: ${fileName} (${pdfData.length} bytes)`);
  
  const startTime = Date.now();
  const apiKey = Deno.env.get('GEMINI_API_KEY');
  
  if (!apiKey) {
    throw new Error('Gemini API key not configured');
  }

  try {
    // For large documents, process in chunks
    const isLargeDocument = pdfData.length > 10 * 1024 * 1024; // 10MB
    
    if (isLargeDocument) {
      console.log('üìö Large document detected, using chunked processing...');
      return await processLargeDocumentWithGemini(pdfData, fileName, apiKey);
    } else {
      console.log('üìÑ Processing standard document with Gemini...');
      return await processSingleDocumentWithGemini(pdfData, fileName, apiKey);
    }
    
  } catch (error) {
    console.error('‚ùå Gemini Vision processing failed:', error);
    throw new Error(`Gemini Vision OCR failed: ${error.message}`);
  }
}

async function processSingleDocumentWithGemini(
  pdfData: Uint8Array,
  fileName: string,
  apiKey: string
): Promise<GeminiOcrResult> {
  const startTime = Date.now();
  
  // Convert PDF to base64 for Gemini API
  const base64Pdf = btoa(String.fromCharCode(...pdfData));
  
  const payload = {
    contents: [{
      parts: [
        {
          text: buildLegalDocumentPrompt(fileName)
        },
        {
          inline_data: {
            mime_type: "application/pdf",
            data: base64Pdf
          }
        }
      ]
    }],
    generationConfig: {
      temperature: 0.1,
      topK: 1,
      topP: 0.8,
      maxOutputTokens: 100000,
    }
  };

  console.log('üöÄ Sending request to Gemini Vision API...');
  
  const response = await fetch(
    `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`,
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload),
    }
  );

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Gemini API error (${response.status}): ${errorText}`);
  }

  const result = await response.json();
  console.log('‚úÖ Gemini Vision response received');
  
  if (!result.candidates || !result.candidates[0] || !result.candidates[0].content) {
    throw new Error('No content generated by Gemini Vision');
  }

  const extractedText = result.candidates[0].content.parts[0].text;
  const processingTime = Date.now() - startTime;
  
  // Calculate confidence based on text quality
  const confidence = calculateTextConfidence(extractedText);
  const pageCount = estimatePageCount(extractedText, pdfData.length);
  
  console.log(`üìä Gemini extraction completed: ${extractedText.length} characters, confidence: ${confidence.toFixed(2)}`);
  
  return {
    text: extractedText,
    confidence,
    pageCount,
    processingTime,
    processingNotes: `Gemini Vision direct PDF processing: ${extractedText.length} characters in ${processingTime}ms`
  };
}

async function processLargeDocumentWithGemini(
  pdfData: Uint8Array,
  fileName: string,
  apiKey: string
): Promise<GeminiOcrResult> {
  console.log('üìö Processing large document with chunked approach...');
  
  const startTime = Date.now();
  const chunkSize = 8 * 1024 * 1024; // 8MB chunks
  const chunks = [];
  
  // Split PDF into chunks
  for (let i = 0; i < pdfData.length; i += chunkSize) {
    const chunk = pdfData.slice(i, i + chunkSize);
    chunks.push(chunk);
  }
  
  console.log(`üìù Split document into ${chunks.length} chunks`);
  
  const extractedTexts = [];
  let totalConfidence = 0;
  
  // Process chunks with rate limiting
  for (let i = 0; i < Math.min(chunks.length, 5); i++) { // Limit to first 5 chunks for efficiency
    console.log(`üîÑ Processing chunk ${i + 1}/${Math.min(chunks.length, 5)}...`);
    
    try {
      const chunkResult = await processSingleDocumentWithGemini(
        chunks[i], 
        `${fileName}_chunk_${i + 1}`, 
        apiKey
      );
      
      if (chunkResult.text.length > 100) {
        extractedTexts.push(chunkResult.text);
        totalConfidence += chunkResult.confidence;
      }
      
      // Rate limiting - wait between chunks
      if (i < chunks.length - 1) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
    } catch (chunkError) {
      console.log(`‚ö†Ô∏è Chunk ${i + 1} failed: ${chunkError.message}`);
      // Continue with other chunks
    }
  }
  
  if (extractedTexts.length === 0) {
    throw new Error('No text extracted from any chunks');
  }
  
  const combinedText = extractedTexts.join('\n\n--- PAGE BREAK ---\n\n');
  const avgConfidence = totalConfidence / extractedTexts.length;
  const processingTime = Date.now() - startTime;
  const pageCount = estimatePageCount(combinedText, pdfData.length);
  
  console.log(`‚úÖ Large document processing completed: ${extractedTexts.length} chunks, ${combinedText.length} total characters`);
  
  return {
    text: combinedText,
    confidence: avgConfidence,
    pageCount,
    processingTime,
    processingNotes: `Gemini Vision chunked processing: ${extractedTexts.length} chunks, ${combinedText.length} characters in ${processingTime}ms`
  };
}

function buildLegalDocumentPrompt(fileName: string): string {
  const isHOADocument = fileName.toLowerCase().includes('hoa') || 
                       fileName.toLowerCase().includes('charter') ||
                       fileName.toLowerCase().includes('bylaws') ||
                       fileName.toLowerCase().includes('ccr');
  
  const isContractDocument = fileName.toLowerCase().includes('contract') ||
                            fileName.toLowerCase().includes('agreement') ||
                            fileName.toLowerCase().includes('lease');
  
  let specificInstructions = '';
  
  if (isHOADocument) {
    specificInstructions = `
This appears to be an HOA (Homeowners Association) document. Pay special attention to:
- Board composition and voting procedures
- Assessment and fee structures
- Architectural guidelines and restrictions
- Common area usage rules
- Violation and enforcement procedures
- Amendment processes
`;
  } else if (isContractDocument) {
    specificInstructions = `
This appears to be a legal contract. Pay special attention to:
- Party names and contact information
- Terms and conditions
- Payment schedules and amounts
- Termination clauses
- Liability and warranty provisions
- Governing law and jurisdiction
`;
  } else {
    specificInstructions = `
This appears to be a legal document. Pay attention to:
- Key legal terms and definitions
- Important dates and deadlines
- Financial amounts and obligations
- Rights and responsibilities of parties
- Procedural requirements
`;
  }

  return `You are a legal document OCR specialist. Extract ALL text from this PDF document with maximum accuracy and completeness.

${specificInstructions}

CRITICAL REQUIREMENTS:
1. Extract ALL visible text - do not summarize or paraphrase
2. Maintain exact formatting, spacing, and structure where possible
3. Preserve section headers, bullet points, and numbering
4. Include all legal clauses, definitions, and fine print
5. Capture all dates, amounts, percentages, and specific terms
6. Maintain paragraph breaks and document structure
7. If tables are present, format them clearly with appropriate spacing
8. Include page numbers or section references if visible
9. Do not omit any content, even if it seems repetitive

For scanned documents:
- Use your best OCR capabilities to read even low-quality text
- If text is unclear, provide your best interpretation
- Include all visible text even if formatting is imperfect

Output the complete extracted text exactly as it appears in the document. This is for legal analysis, so accuracy and completeness are essential.`;
}

function calculateTextConfidence(text: string): number {
  if (!text || text.length < 50) return 0.1;
  
  // Check for legal document indicators
  const legalTerms = [
    'agreement', 'contract', 'whereas', 'therefore', 'party', 'parties',
    'section', 'article', 'clause', 'provision', 'terms', 'conditions',
    'liability', 'warranty', 'governing', 'jurisdiction', 'amendment',
    'bylaws', 'charter', 'board', 'association', 'homeowners'
  ];
  
  const foundTerms = legalTerms.filter(term => 
    text.toLowerCase().includes(term)
  ).length;
  
  // Base confidence
  let confidence = 0.6;
  
  // Boost for legal terms
  confidence += Math.min(foundTerms * 0.05, 0.3);
  
  // Boost for document structure
  if (text.includes('SECTION') || text.includes('ARTICLE')) confidence += 0.1;
  if (text.includes('WHEREAS') || text.includes('THEREFORE')) confidence += 0.1;
  
  // Boost for length (more text generally means better extraction)
  if (text.length > 1000) confidence += 0.05;
  if (text.length > 5000) confidence += 0.05;
  if (text.length > 10000) confidence += 0.05;
  
  return Math.min(confidence, 0.95);
}

function estimatePageCount(text: string, fileSize: number): number {
  // Multiple estimation methods
  const charBasedPages = Math.max(1, Math.ceil(text.length / 3000)); // ~3000 chars per page
  const sizeBasedPages = Math.max(1, Math.ceil(fileSize / 50000)); // ~50KB per page
  
  // Use the more conservative estimate
  return Math.max(charBasedPages, Math.min(sizeBasedPages, charBasedPages * 2));
}