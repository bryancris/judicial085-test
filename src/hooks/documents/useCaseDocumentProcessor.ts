
import { useState, useCallback } from 'react';
import { supabase } from "@/integrations/supabase/client";
import { useToast } from "@/hooks/use-toast";
import { generateEmbeddings, processPdfDocument } from "@/utils/pdfUtils";
import { chunkDocument } from "@/utils/documents/documentUtils";

export const useCaseDocumentProcessor = (
  clientId: string | undefined,
  caseId: string | undefined,
  onRefresh: () => void
) => {
  const [isProcessing, setIsProcessing] = useState(false);
  const { toast } = useToast();

  const processDocument = useCallback(async (
    title: string, 
    content: string, 
    metadata: any = {},
    file?: File
  ) => {
    if (!clientId || !caseId) {
      console.error("Cannot process document: No client ID or case ID provided");
      return { success: false, error: "No client ID or case ID provided" };
    }
    
    setIsProcessing(true);
    
    try {
      // If it's a PDF or Word file, use the PDF processing pipeline (which supports both)
      if (file && (file.type === 'application/pdf' || 
                   file.type.includes('wordprocessingml') || 
                   file.name.toLowerCase().endsWith('.docx'))) {
        console.log("Processing file:", file.name, "Type:", file.type);
        
        const result = await processPdfDocument(file, title, clientId, caseId);
        
        if (result.success) {
          const fileType = file.type === 'application/pdf' ? 'PDF' : 'Word document';
          toast({
            title: `${fileType} processed successfully`,
            description: `Your ${fileType.toLowerCase()} has been uploaded and vectorized for search.`,
          });
          
          // Refresh the document list
          onRefresh();
          return result;
        } else {
          throw new Error(result.error || `Failed to process ${file.type === 'application/pdf' ? 'PDF' : 'Word document'}`);
        }
      }
      
      // Generate a unique ID for the document
      const documentId = crypto.randomUUID();
      
      // Insert document metadata with case_id
      const { error: metadataError } = await supabase
        .from('document_metadata')
        .insert({
          id: documentId,
          title,
          client_id: clientId,
          case_id: caseId,
          schema: 'case_document',
          url: metadata.pdfUrl || null,
          include_in_analysis: false // Default to false for new documents
        });
      
      if (metadataError) {
        throw new Error(`Error creating document metadata: ${metadataError.message}`);
      }
      
      if (metadata.isPdfDocument) {
        // Embeddings already generated by the upload process
        // Refresh the document list
        await onRefresh();
        
        return { success: true, documentId };
      }
      
      // For text documents, use the original chunking logic
      const chunks = chunkDocument(content);
      
      // Get embeddings for each chunk from OpenAI
      try {
        await generateEmbeddings(chunks, documentId, clientId, { ...metadata, caseId });
      } catch (embeddingError) {
        console.error("Error generating embeddings:", embeddingError);
        
        // If embedding fails, we'll still store the chunks without embeddings
        // Upload each chunk
        for (let i = 0; i < chunks.length; i++) {
          const chunk = chunks[i];
          
          // Store each chunk in the database with case_id
          const { error: chunkError } = await supabase
            .from('document_chunks')
            .insert({
              document_id: documentId,
              client_id: clientId,
              case_id: caseId,
              chunk_index: i,
              content: chunk,
              metadata: { ...metadata, chunkIndex: i, totalChunks: chunks.length, caseId }
            });
          
          if (chunkError) {
            throw new Error(`Error storing chunk ${i}: ${chunkError.message}`);
          }
        }
      }
      
      // Refresh the document list
      await onRefresh();
      
      return { success: true, documentId };
      
    } catch (error: any) {
      console.error("Error processing case document:", error);
      
      toast({
        title: "Document processing failed",
        description: error.message || "An error occurred while processing the document.",
        variant: "destructive",
      });
      
      return { success: false, error: error.message };
    } finally {
      setIsProcessing(false);
    }
  }, [clientId, caseId, onRefresh, toast]);

  return {
    isProcessing,
    processDocument
  };
};
